<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[Cookie & Session]]></title>
    <url>%2F2019%2F04%2F07%2FCookie-Session%2F</url>
    <content type="text"><![CDATA[https://www.cnblogs.com/liwenzhou/p/8343243.html CookieCookie是什么保存在浏览器端的键值对 为什么要有Cookie因为HTTP请求是无状态的 Cookie的原理服务端可以在返回响应的时候 做手脚在浏览器上写入键值对，就是Cookie，浏览器发送请求的时候会自动携带该网站保存在浏览器中的键值对 Cookie的使用场景 保存登录信息 保存用户的搜索关键词 Django中操作Cookie获取Cookie1234567request.COOKIES['key']request.get_signed_cookie(key, default=RAISE_ERROR, salt='', max_age=None)参数： default: 默认值 salt: 加密盐 max_age: 后台控制过期时间 设置Cookie123456789101112131415rep = HttpResponse(...)rep ＝ render(request, ...)rep.set_cookie(key,value,...)rep.set_signed_cookie(key,value,salt='加密盐', max_age=None, ...)参数： key, 键 value='', 值 max_age=None, 超时时间 expires=None, 超时时间(IE requires expires, so set it if hasn't been already.) path='/', Cookie生效的路径，/ 表示根路径，特殊的：根路径的cookie可以被任何url的页面访问 domain=None, Cookie生效的域名 secure=False, https传输 httponly=False 只能http协议传输，无法被JavaScript获取（不是绝对，底层抓包可以获取到也可以被覆盖） 删除Cookie1234def logout(request): rep = redirect("/login/") rep.delete_cookie("user") # 删除用户浏览器上之前设置的usercookie值 return rep 完整views.py示例：12345678910111213141516171819202122232425262728293031323334353637383940414243444546# -*- coding: utf-8 -*-from __future__ import unicode_literalsfrom django.shortcuts import render,redirectfrom django.http import HttpResponse,HttpResponseRedirectfrom django.shortcuts import render# Create your views here.def check_login(func): def a(request,*args,**kwargs): Cookies = request.COOKIES.get("is_login", None) if 'yes' != Cookies: return redirect('/test01/login') else: return func(request,*args,**kwargs) return a@check_logindef index(request): return HttpResponse('index界面')@check_logindef home(request): return HttpResponse('home')def login(request): return render(request,'test01/login.html')@check_logindef logout(request): rep = redirect('/test01/login') rep.delete_cookie('is_login') return repdef check_username(request): if request.method == "POST": username = request.POST.get('username',None) password = request.POST.get('password',None) if username == 'z' and password == 'z': rep = render(request,'test01/home.html',&#123;'username':username&#125;) #rep.set_cookie('is_login','yes') rep.set_signed_cookie('is_login', 'yes', expires=60 * 60 * 24 * 7) else: rep = redirect('/test01/login') else: rep = redirect('/test01/login') return rep SessionCookie虽然在一定程度上解决了“保持状态”的需求，但是由于Cookie本身最大支持4096字节，以及Cookie本身保存在客户端，可能被拦截或窃取，因此就需要有一种新的东西，它能支持更多的字节，并且他保存在服务器，有较高的安全性。这就是Session。 问题来了，基于HTTP协议的无状态特征，服务器根本就不知道访问者是“谁”。那么上述的Cookie就起到桥接的作用。 我们可以给每个客户端的Cookie分配一个唯一的id，这样用户在访问时，通过Cookie，服务器就知道来的人是“谁”。然后我们再根据不同的Cookie的id，在服务器上保存一段时间的私密资料，如“账号密码”等等。 总结而言：Cookie弥补了HTTP无状态的不足，让服务器知道来的人是“谁”；但是Cookie以文本的形式保存在本地，自身安全性较差；所以我们就通过Cookie识别不同的用户，对应的在Session里保存私密的信息以及超过4096字节的文本。另外，上述所说的Cookie和Session其实是共通性的东西，不限于语言和框架。 Django中操作Session1234567891011121314151617181920212223242526272829303132333435363738# 获取、设置、删除Session中数据request.session['k1']request.session.get('k1',None)request.session['k1'] = 123request.session.setdefault('k1',123) # 存在则不设置del request.session['k1']# 所有 键、值、键值对request.session.keys()request.session.values()request.session.items()request.session.iterkeys()request.session.itervalues()request.session.iteritems()# 会话session的keyrequest.session.session_key# 将所有Session失效日期小于当前日期的数据删除request.session.clear_expired()# 检查会话session的key在数据库中是否存在request.session.exists("session_key")# 删除当前会话的所有Session数据request.session.delete() # 删除当前的会话数据并删除会话的Cookie。request.session.flush() 这用于确保前面的会话数据不可以再次被用户的浏览器访问 例如，django.contrib.auth.logout() 函数中就会调用它。# 设置会话Session和Cookie的超时时间request.session.set_expiry(value) * 如果value是个整数，session会在些秒数后失效。 * 如果value是个datatime或timedelta，session就会在这个时间后失效。 * 如果value是0,用户关闭浏览器session就会失效。 * 如果value是None,session会依赖全局session失效策略。 Seesion版验证登录12345678910111213141516171819202122232425262728293031323334353637383940from functools import wrapsdef check_login(func): @wraps(func) def inner(request, *args, **kwargs): next_url = request.get_full_path() if request.session.get("user"): return func(request, *args, **kwargs) else: return redirect("/login/?next=&#123;&#125;".format(next_url)) return innerdef login(request): if request.method == "POST": user = request.POST.get("user") pwd = request.POST.get("pwd") if user == "alex" and pwd == "alex1234": # 设置session request.session["user"] = user # 获取跳到登陆页面之前的URL next_url = request.GET.get("next") # 如果有，就跳转回登陆之前的URL if next_url: return redirect(next_url) # 否则默认跳转到index页面 else: return redirect("/index/") return render(request, "login.html")@check_logindef logout(request): # 删除所有当前请求相关的session request.session.delete() return redirect("/login/")@check_logindef index(request): current_user = request.session.get("user", None) return render(request, "index.html", &#123;"user": current_user&#125;) Django中的Session配置12345678910111213141516171819202122232425261. 数据库SessionSESSION_ENGINE = 'django.contrib.sessions.backends.db' # 引擎（默认）2. 缓存SessionSESSION_ENGINE = 'django.contrib.sessions.backends.cache' # 引擎SESSION_CACHE_ALIAS = 'default' # 使用的缓存别名（默认内存缓存，也可以是memcache），此处别名依赖缓存的设置3. 文件SessionSESSION_ENGINE = 'django.contrib.sessions.backends.file' # 引擎SESSION_FILE_PATH = None # 缓存文件路径，如果为None，则使用tempfile模块获取一个临时地址tempfile.gettempdir() 4. 缓存+数据库SESSION_ENGINE = 'django.contrib.sessions.backends.cached_db' # 引擎5. 加密Cookie SessionSESSION_ENGINE = 'django.contrib.sessions.backends.signed_cookies' # 引擎其他公用设置项：SESSION_COOKIE_NAME ＝ "sessionid" # Session的cookie保存在浏览器上时的key，即：sessionid＝随机字符串（默认）SESSION_COOKIE_PATH ＝ "/" # Session的cookie保存的路径（默认）SESSION_COOKIE_DOMAIN = None # Session的cookie保存的域名（默认）SESSION_COOKIE_SECURE = False # 是否Https传输cookie（默认）SESSION_COOKIE_HTTPONLY = True # 是否Session的cookie只支持http传输（默认）SESSION_COOKIE_AGE = 1209600 # Session的cookie失效日期（2周）（默认）SESSION_EXPIRE_AT_BROWSER_CLOSE = False # 是否关闭浏览器使得Session过期（默认）SESSION_SAVE_EVERY_REQUEST = False # 是否每次请求都保存Session，默认修改之后才保存（默认）]]></content>
  </entry>
  <entry>
    <title><![CDATA[Nginx_配置SSL证书]]></title>
    <url>%2F2019%2F04%2F05%2FNginx-%E9%85%8D%E7%BD%AESSL%E8%AF%81%E4%B9%A6%2F</url>
    <content type="text"><![CDATA[Nginx配置SSL证书，实现HTTPS访问 获取证书并上传到Ngx服务器 检查Ngx是否安装–with-http_ssl_module模块 修改nginx配置文件 123456789101112131415161718192021222324252627282930313233server &#123; listen 80; server_name *.zhaohongye.com; #return 301 https://$host$request_uri; return 301 https://zhaohongye.com;&#125;server &#123; listen 443 ssl; server_name zhaohongye.com www.zhaohongye.com; access_log /var/log/nginx/zhy.log main; error_log /var/log/nginx/zhy.error.log; ssl on; #ssl功能开启 ssl_certificate sslfile/2027481_zhaohongye.com.pem; ssl_certificate_key sslfile/2027481_zhaohongye.com.key; location / &#123; proxy_set_header Host $host:$server_port; proxy_set_header X-Real-IP $remote_addr; proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for; proxy_set_header X-Forwarded-Proto $scheme; proxy_redirect http:// https://; proxy_pass http://127.0.0.1:4000; client_max_body_size 10M; proxy_set_header X-Forwarded-Host $host; proxy_set_header X-Forwarded-Server $host; # Required for new HTTP-based CLI proxy_http_version 1.1; proxy_request_buffering off; &#125;&#125; https访问验证]]></content>
      <categories>
        <category>Nginx</category>
      </categories>
      <tags>
        <tag>Linux</tag>
        <tag>Nginx</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Archer]]></title>
    <url>%2F2019%2F04%2F05%2FArcher%2F</url>
    <content type="text"><![CDATA[ARCHER — 自动化SQL操作平台基于inception的自动化SQL操作平台，支持SQL执行、LDAP认证、发邮件、OSC、SQL查询、SQL优化建议、权限管理等功能，支持docker镜像。 GitHub项目地址：https://github.com/jly8866/archer 主要功能 自动审核发起SQL上线，工单提交，由inception自动审核，审核通过后需要由审核人进行人工审核 人工审核inception自动审核通过的工单，由其他研发工程师或研发经理来审核，DBA操作执行SQL为什么要有人工审核？这是遵循运维领域线上操作的流程意识，一个工程师要进行线上数据库SQL更新，最好由另外一个工程师来把关很多时候DBA并不知道SQL的业务含义，所以人工审核最好由其他研发工程师或研发经理来审核. 这是archer的设计理念 回滚数据展示工单内可展示回滚语句，支持一键提交回滚工单 定时执行SQL审核通过的工单可由DBA选择定时执行，执行前可修改执行时间，可随时终止 pt-osc执行支持pt-osc执行进度展示，并且可以点击中止pt-osc进程 MySQL查询库、表、关键字自动补全查询结果集限制、查询结果导出、表结构展示、多结果集展示 MySQL查询权限管理基于inception解析查询语句，查询权限支持限制到表级查询权限申请、审核和管理，支持审核流程配置，多级审核 MySQL查询动态脱敏基于inception解析查询语句，配合脱敏字段配置、脱敏规则(正则表达式)实现敏感数据动态脱敏 慢日志管理基于percona-toolkit的pt_query_digest分析和存储慢日志，并在web端展现 邮件通知可配置邮件提醒，对上线申请、权限申请、审核结果等进行通知对异常登录进行通知 安装安装docker 、git1yum install -y docker git 下载镜像123docker pull hhyo/inceptiondocker pull hhyo/archerdocker pull mysql:5.6.35 创建archer配置文件服务目录定为 /vcg/archer/ 1mkdir /vcg/archer/ 123456789101112131415161718192021222324vim /vcg/archer/inc.cnf[inception]general_log=1general_log_file=inception.logport=6669socket=/tmp/inc.socketcharacter-set-client-handshake=0character-set-server=utf8inception_remote_system_password=rootinception_remote_system_user=wzf1inception_remote_backup_port=3306inception_remote_backup_host=127.0.0.1inception_support_charset=utf8,utf8mb4inception_enable_nullable=0inception_check_primary_key=1inception_check_column_comment=1inception_check_table_comment=1inception_osc_on=OFFinception_osc_bin_dir=/usr/bininception_osc_min_table_size=1inception_osc_chunk_time=0.1inception_enable_blob_type=1inception_check_column_default_value=1 12wget https://github.com/jly8866/archer/blob/master/archer/settings.py修改其中的数据库地址、用户名、密码 启动容器12345docker run --name inception -v /vcg/archer/inc.cnf:/etc/inc.cnf -p 6669:6669 -dti hhyo/inceptiondocker run --name mysql -p 3306:3306 -e MYSQL_ROOT_PASSWORD=123456 -d mysql:5.6.35docker run --name archer -v /vcg/archer/settings.py:/opt/archer/archer/settings.py -e NGINX_PORT=9123 -p 9123:9123 -dti hhyo/archer 创建数据库123mysql -uroot -pCREATE DATABASE IF NOT EXISTS archer_github DEFAULT CHARSET utf8 COLLATE utf8_general_ci; 初始化数据库12345678docker exec -ti archer /bin/bash cd /opt/archer source /opt/venv4archer/bin/activate # 初始化数据库 python3 manage.py makemigrations sql python3 manage.py migrate # 创建管理员账号 python3 manage.py createsuperuser 访问地址： http://xxxx::9123/]]></content>
      <categories>
        <category>Archer</category>
      </categories>
      <tags>
        <tag>Archer</tag>
        <tag>Linux</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Hexo]]></title>
    <url>%2F2019%2F04%2F05%2FHexo%2F</url>
    <content type="text"><![CDATA[快速、简洁且高效的博客框架官网: https://hexo.io 特点超快速度Node.js 所带来的超快生成速度，让上百个页面在几秒内瞬间完成渲染。 支持 MarkdownHexo 支持 GitHub Flavored Markdown 的所有功能，甚至可以整合 Octopress 的大多数插件。 一键部署只需一条指令即可部署到 GitHub Pages, Heroku 或其他网站。 丰富的插件Hexo 拥有强大的插件系统，安装插件可以让 Hexo 支持 Jade, CoffeeScript。 12345$ npm install hexo-cli -g$ hexo init blog$ cd blog$ npm install$ hexo server 最佳实践命令缩写hexo支持指令缩写，例如：hexo generate和hexo g是等效的。d = deploy 部署g = generate 生成静态页面l = log 启动日记记录，使用覆盖记录格式n = new 新建文章o = output 设置输出路径p = port 重设端口s = server 启动服务器w = watch 监视文件变动 组合命令1hexo clean &amp;&amp; hexo g &amp;&amp; hexo d 修改首页博客为预览模式12345vim themes/next/_config.ymlauto_excerpt: enable: false length: 150 将 auto_excerpt的enable参数由false改为true]]></content>
  </entry>
  <entry>
    <title><![CDATA[Kubernetes_Nginx-Ingress]]></title>
    <url>%2F2019%2F04%2F05%2FKubernetes-Nginx-Ingress%2F</url>
    <content type="text"><![CDATA[For example12345678910111213141516171819202122232425262728293031apiVersion: extensions/v1beta1kind: Ingressmetadata: annotations: nginx.ingress.kubernetes.io/force-ssl-redirect: 'true' #代表其中跳转 nginx.ingress.kubernetes.io/service-weight: '' nginx.ingress.kubernetes.io/ssl-redirect: 'true' creationTimestamp: '2018-12-25T10:29:36Z' generation: 1 name: boss namespace: default resourceVersion: '21429383' selfLink: /apis/extensions/v1beta1/namespaces/default/ingresses/boss uid: fa56e2a0-082f-11e9-80cf-00163e0e2421spec: rules: - host: boss1.vcg.com http: paths: - backend: serviceName: node-vcg-boss servicePort: 80 path: / tls: - hosts: - boss1.vcg.com secretName: vcg-httpsstatus: loadBalancer: ingress: - ip: 39.97.21.16]]></content>
      <categories>
        <category>Kubernetes</category>
      </categories>
      <tags>
        <tag>Kubernetes</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Hello World]]></title>
    <url>%2F2019%2F04%2F03%2Fhello-world%2F</url>
    <content type="text"><![CDATA[Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new "My New Post" More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment]]></content>
  </entry>
</search>
