<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[Kubernetes-kubectl]]></title>
    <url>%2F2019%2F04%2F21%2FKubernetes-kubectl%2F</url>
    <content type="text"><![CDATA[管理Kubernetes集群的工具 安装下载最新版的kubectl客户端https://github.com/kubernetes/kubernetes/blob/master/CHANGELOG.md 安装和配置https://kubernetes.io/docs/tasks/tools/install-kubectl/ 验证1kuberctl version 配置集群凭证您可以使用scp命令安全地将主节点的配置从 Kubernetes 集群主 VM 中的 /etc/kubernetes/kube.conf 复制到本地计算机的 $HOME/.kube/config（kubectl 预期凭据所在的位置）。 12mkdir $HOME/.kubescp root@&lt;master-public-ip&gt;:/etc/kubernetes/kube.conf $HOME/.kube/config 公有云环境也可以在集群配置页面获取到config配置 验证1kubect get all 使用help-获取帮助信息123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475zhaohongye ~ ^-^ #kubectl helpkubectl controls the Kubernetes cluster manager.Find more information at: https://kubernetes.io/docs/reference/kubectl/overview/Basic Commands (Beginner): create Create a resource from a file or from stdin. expose 使用 replication controller, service, deployment 或者 pod并暴露它作为一个 新的 Kubernetes Service run 在集群中运行一个指定的镜像 set 为 objects 设置一个指定的特征 run-container 在集群中运行一个指定的镜像. This command isdeprecated, use "run" insteadBasic Commands (Intermediate): get 显示一个或更多 resources explain 查看资源的文档 edit 在服务器上编辑一个资源 delete Delete resources by filenames, stdin, resources and names, orby resources and label selectorDeploy Commands: rollout Manage the rollout of a resource rolling-update 完成指定的 ReplicationController 的滚动升级 scale 为 Deployment, ReplicaSet, Replication Controller 或者 Job设置一个新的副本数量 autoscale 自动调整一个 Deployment, ReplicaSet, 或者ReplicationController 的副本数量Cluster Management Commands: certificate 修改 certificate 资源. cluster-info 显示集群信息 top Display Resource (CPU/Memory/Storage) usage. cordon 标记 node 为 unschedulable uncordon 标记 node 为 schedulable drain Drain node in preparation for maintenance taint 更新一个或者多个 node 上的 taintsTroubleshooting and Debugging Commands: describe 显示一个指定 resource 或者 group 的 resources 详情 logs 输出容器在 pod 中的日志 attach Attach 到一个运行中的 container exec 在一个 container 中执行一个命令 port-forward Forward one or more local ports to a pod proxy 运行一个 proxy 到 Kubernetes API server cp 复制 files 和 directories 到 containers和从容器中复制 files 和 directories. auth Inspect authorizationAdvanced Commands: apply 通过文件名或标准输入流(stdin)对资源进行配置 patch 使用 strategic merge patch 更新一个资源的 field(s) replace 通过 filename 或者 stdin替换一个资源 convert 在不同的 API versions 转换配置文件Settings Commands: label 更新在这个资源上的 labels annotate 更新一个资源的注解 completion Output shell completion code for the specified shell (bash orzsh)Other Commands: api-versions Print the supported API versions on the server, in the form of"group/version" config 修改 kubeconfig 文件 help Help about any command plugin Runs a command-line plugin version 输出 client 和 server 的版本信息Usage: kubectl [flags] [options]Use "kubectl &lt;command&gt; --help" for more information about a given command.Use "kubectl options" for a list of global command-line options (applies to allcommands). get-获取信息Display one or many resources 123456789101112131415161718192021222324252627Examples: # List all pods in ps output format. kubectl get pods # List all pods in ps output format with more information (such as node name). kubectl get pods -o wide # List a single replication controller with specified NAME in ps output format. kubectl get replicationcontroller web # List a single pod in JSON output format. kubectl get -o json pod web-pod-13je7 # List a pod identified by type and name specified in "pod.yaml" in JSON output format. kubectl get -f pod.yaml -o json # Return only the phase value of the specified pod. kubectl get -o template pod/web-pod-13je7 --template=&#123;&#123;.status.phase&#125;&#125; # List all replication controllers and services together in ps output format. kubectl get rc,services # List one or more resources by their type and names. kubectl get rc/web service/frontend pods/web-pod-13je7 # List all resources with different types. kubectl get all scale-扩缩容Set a new size for a Deployment, ReplicaSet, Replication Controller, or StatefulSet. 123456789101112131415161718Examples: # Scale a replicaset named &apos;foo&apos; to 3. kubectl scale --replicas=3 rs/foo # Scale a resource identified by type and name specified in &quot;foo.yaml&quot; to 3. kubectl scale --replicas=3 -f foo.yaml # If the deployment named mysql&apos;s current size is 2, scale mysql to 3. kubectl scale --current-replicas=2 --replicas=3 deployment/mysql # Scale multiple replication controllers. kubectl scale --replicas=5 rc/foo rc/bar rc/baz # Scale statefulset named &apos;web&apos; to 3. kubectl scale --replicas=3 statefulset/web kubectl scale Deployment node-vcg-web --replicas=1 kubectl scale Deployment node-vcg-web --replicas=10 批量扩缩容 123for i in `kubectl get deployment | awk '&#123;print $1&#125;' |grep -v NAME`; do kubectl scale Deployment $i --replicas=1done exec-在container中执行命令Execute a command in a container. 123456789Options: -c, --container='': Container name. If omitted, the first container in the pod will be chosen -p, --pod='': Pod name -i, --stdin=false: Pass stdin to the container -t, --tty=false: Stdin is a TTYExamples: kubectl exec 123456-7890 -c ruby-container -it -- bash -ilUsage: kubectl exec POD [-c CONTAINER] -- COMMAND [args...] [options]]]></content>
      <categories>
        <category>Kubernetes</category>
      </categories>
      <tags>
        <tag>Kubernetes</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Hexo-博客中添加图片等资源]]></title>
    <url>%2F2019%2F04%2F21%2FHexo-%E5%8D%9A%E5%AE%A2%E4%B8%AD%E6%B7%BB%E5%8A%A0%E5%9B%BE%E7%89%87%E7%AD%89%E8%B5%84%E6%BA%90%2F</url>
    <content type="text"><![CDATA[引用于 https://blog.csdn.net/qq_40265501/article/details/80019774 官方介绍：https://hexo.io/zh-cn/docs/asset-folders.html 一图胜万言 博客中有时候图片比文字更有说服力，比如：代码运行结果，代码运行效果等 开启’资源文件管理’功能将 config.yml文件中的 post_asset_folder 选项设为 true 12_config.ymlpost_asset_folder: true 安装Hexo插件插件地址：https://github.com/dangxuandev/hexo-asset-image 1npm install hexo-asset-image --save 在博客中添加图片 新建博客 1hexo n test 查看目录结构 123[root@nginx GeekSRE]# ls -l source/_posts/ |grep testdrwxr-xr-x 2 root root 4096 4月 17 17:29 test-rw-r--r-- 1 root root 96 4月 17 17:35 test.md 可以看到 会在 source/_posts 目录创建 test.md 和 test目录 与博客同名目录用于存放资源文件，如图片、CSS、JS 文件等 上传图片到”文章资源文件夹” 123# 比如使用CSDN博客中的图片：cd source/_posts/testwget https://img-blog.csdn.net/20180420154609543 引用 12345vim source/_posts/test.md# ![你想要输入的替代文字](图片文件)# 比如：![图片](test.jpg) 保存 1hexo clean &amp;&amp; hexo g &amp;&amp; hexo d 验证效果]]></content>
      <tags>
        <tag>Hexo</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[GitLab代码托管]]></title>
    <url>%2F2019%2F04%2F16%2FGitLab%E4%BB%A3%E7%A0%81%E6%89%98%E7%AE%A1%2F</url>
    <content type="text"><![CDATA[GitLab 是一个用于仓库管理系统的开源项目，使用Git作为代码管理工具，并在此基础上搭建起来的web服务。 官网：https://about.gitlab.com/stages-devops-lifecycle/ 安装配置Yum源 123456vim /etc/yum.repos.d/gitlab_gitlab-ee.repo[gitlab-ce]name=Gitlab CE Repositorybaseurl=https://mirrors.tuna.tsinghua.edu.cn/gitlab-ce/yum/el$releasever/gpgcheck=0enabled=1 安装 12yum install -y postfixyum install gitlab-ce -y 配置配置文件：/etc/gitlab/gitlab.rb (建议每次修改前备份此文件) 1234567891011121314151617181920212223242526272829 external_url 'https://git.visualchina.com' # 域名配置 gitlab_rails['time_zone'] = 'Asia/Shanghai' # 时区 nginx['redirect_http_to_https'] = true # SSL证书 nginx['ssl_certificate'] = "/data/vcg/ssl/visualchina.pem" nginx['ssl_certificate_key'] = "/data/vcg/ssl/visualchina.key" gitlab_rails['ldap_enabled'] = truegitlab_rails['ldap_servers'] = YAML.load &lt;&lt;-'EOS' # remember to close this block with 'EOS' below main: # 'main' is the GitLab 'provider ID' of this LDAP server label: 'LDAP' host: '172.16.239.3' port: 389 uid: 'cn' method: 'plain' # "tls" or "ssl" or "plain" bind_dn: 'cn=root,dc=vcg,dc=com' password: '*******' # 管理员密码 active_directory: true allow_username_or_email_login: false block_auto_created_users: false base: 'ou=People,dc=vcg,dc=com' user_filter: '' attributes: username: ['cn'] email: ['mail'] name: 'cn' first_name: 'givenName' last_name: 'sn'EOS 升级升级规范：https://docs.gitlab.com/ee/policy/maintenance.html#upgrade-recommendations 升级建议：首先升级到主要版本中的最新可用次要版本 例如：8.13.4 升级到 11.3.4 ，升级路径为 8.13.4 -&gt; 8.17.7 -&gt; 9.5.10 -&gt; 10.8.7 -&gt; 11.3.4 ​ 即：8.17.7是版本8中的最后一个版本, 9.5.10是版本9中的最后一个版本, 10.8.7是版本10中的最后一个版本 本次升级版本为 10.7.0 ，升级到最新版本 11.9.8 ，注：2019年04月16日 1、下载10.8.7版本的rpm包 1wget https://mirrors.tuna.tsinghua.edu.cn/gitlab-ce/yum/el7/gitlab-ce-10.8.7-ce.0.el7.x86_64.rpm 2、安装升级到10.8.7版本 1rpm -Uvh gitlab-ce-10.8.7-ce.0.el7.x86_64.rpm 3、再升级到11.9.8版本 1yum install gitlab-ce.x86_64]]></content>
      <categories>
        <category>GitLab</category>
      </categories>
      <tags>
        <tag>GitLab</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[域名SSL证书]]></title>
    <url>%2F2019%2F04%2F16%2F%E5%9F%9F%E5%90%8DSSL%E8%AF%81%E4%B9%A6%2F</url>
    <content type="text"><![CDATA[SSL证书 什么是数字证书？ 数字证书是一个经权威授权机构数字签名、包含公开密钥拥有者信息以及公开密钥的文件，是权威机构颁发给网站的可信凭证。最简单的证书包含一个公开密钥、证书名称以及证书授权中心的数字签名。 数字证书还有一个重要的特征：只在特定的时间段内有效。 什么是SSL？ SSL协议是一种可实现网络通信加密的安全协议，可在浏览器和网站之间建立加密通道，保障数据在传输的过程中不被篡改或窃取。 什么是SSL证书？ SSL证书采用SSL协议进行通信，是由权威机构颁发给网站的可信凭证。 SSL证书采用SSL协议进行通信。SSL证书部署到Web服务器后，Web服务器访问将启用HTTPS协议。您的网站将会通过 HTTPS 加密协议来传输数据，可帮助Web服务器和网站间建立可信的加密链接，从而保证网络数据传输的安全。 什么是HTTPS？ HTTPS是一种基于SSL协议的网站加密传输协议。 网站安装SSL证书后，使用HTTPS加密协议访问，可激活客户端浏览器到网站服务器之间的SSL加密通道（SSL协议），从而实现高强度双向加密传输，防止传输数据被泄露或篡改。HTTPS 也就是HTTP + SSL，是HTTP的安全版。 什么是CA认证中心？ CA认证中心（CA机构），即证书授权中心（Certificate Authority），或称证书授权机构。 CA认证中心作为电子商务交易中受信任的第三方，承担公钥体系中公钥合法性检验的责任。 SSL证书类型配置表证书根据不同的验证级别，分为以下三类： 域名型SSL（DV SSL） 企业型SSL（OV SSL） 增强型SSL（EV SSL） 根据保护域名的数量需求，SSL 证书又分为： 单域名版：只保护一个域名，例如 www.abc.com 或者 login.abc.com 之类的单个域名 多域名版：一张证书可以保护多个域名，例如同时保护 www.abc.com , www.bcd.com, pay.efg.com 等 通配符版：一张证书保护同一个主域名下同一级的所有子域名，不限个数，形如 *.abc.com 。注意，通配符版只有 DVSSL 和 OVSSL 具有， EVSSL 不具有通配符版本。 证书品牌 证书类型 保护域名的类型 说明 GeoTrust 专业版OV SSL 1个带通配符的域名1个明细域名多个明细域名 提供加密功能，对申请者的身份进行严格的审核验证，可提供可信身份证明。多个域名例上限为300个。如: buy1.example.com, buy2.example.com, next.buy.example2.com, 上述3个明细子域名计算为3个域名。 高级版EV SSL 1个域名多个域名 提供加密功能，对申请者做最严格的身份审核验证，提供最高度可信身份证明，提供浏览器绿色地址栏。 GlobalSign 专业版OV SSL 通配符域名 提供加密功能，对申请者进行严格的身份审核验证，提供可信身份证明。 CFCA 专业版OV SSL 通配符域名1个域名多个域名 提供加密功能，对申请者进行严格的身份审核验证，提供可信身份证明。 高级版EV SSL 1个域名多个域名 提供加密功能，对申请者做最严格的身份审核验证，提供最高度可信身份证明，提供浏览器绿色地址栏。 Symantec 专业版OV SSL 通配符域名1个域名多个域名 提供加密功能，对申请者进行严格的身份审核验证，提供可信身份证明。 通配符DV SSL 通配符域名 增强型OV SSL 1个域名多个域名 提供站点加密功能，需要核验组织注册信息，证书中会显示组织名称。组织信息验证通过后，3个工作日内颁发证书。 高级版EV SSL 1个域名多个域名 提供加密功能，对申请者做最严格的身份审核验证，提供最高度可信身份证明，提供浏览器绿色地址栏。 增强型EV SSL 1个域名多个域名 增强型EV SSL提供站点加密功能，浏览器绿色地址栏显示组织信息强化信任。组织信息验证通过后7个工作日内颁发证书。 免费型DV SSL 1个域名 免费新根证书，切入DigiCert PKI体系，兼容性操作系统版本IOS 5.0+、Android 2.3.3+、JRE 1.6.5+、WIN 7+。最多保护一个明细子域名，不支持通配符，一个阿里云帐户最多签发20张免费证书。 SSL证书购买登录阿里云控制台，进入SSL证书服务。 SSL证书更新公司域名SSL证书即将到期，替换SSL证书需知道哪些二级域名使用了HTTPS访问，并且获取SSL证书过期时间，来验证证书是否更新。 获取域名下的解析信息登录域名服务商控制条—云解析—域名解析列表—导出解析记录 将二级域名的记录写入domains.txt文件备用 编写脚本1234567891011#!/bin/bashfor domain in `cat domains.txt` #读取存储了需要监测的域名的文件do curl $domain.vcg.com:443 1&gt;/dev/null 2&gt;/dev/null --connect-timeout 3 if [[ $? -eq 0 ]]; then END_TIME=$(echo | openssl s_client -servername $domain.vcg.com -connect $domain.vcg.com:443 2&gt;/dev/null | openssl x509 -noout -dates |grep 'After'| awk -F '=' '&#123;print $2&#125;'| awk -F ' +' '&#123;print $1,$2,$4 &#125;' ) echo "$domain.vcg.com 的SSL证书到期时间为 $END_TIME " &gt;&gt; result1.txt else echo "$domain.vcg.com 没https " &gt;&gt; result1.txt fidone 根据输出文件查看SSL证书过期时间，进行证书替换工作SSL证书更新的配置路径 阿里云OSS-对象存储 阿里云WAF-Web防火墙 阿里云SLB-负载均衡 Nginx #####]]></content>
      <categories>
        <category>Linux</category>
        <category>SSL证书</category>
      </categories>
      <tags>
        <tag>Linux</tag>
        <tag>SSL证书</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[暴力破解攻击和防御]]></title>
    <url>%2F2019%2F04%2F16%2F%E6%9A%B4%E5%8A%9B%E7%A0%B4%E8%A7%A3%E6%94%BB%E5%87%BB%E5%92%8C%E9%98%B2%E5%BE%A1%2F</url>
    <content type="text"><![CDATA[引用自阿里云https://help.aliyun.com/knowledge_detail/56269.html 什么是暴力破解攻击暴力破解攻击是指攻击者通过系统地组合并尝试所有的可能性以破解用户的用户名、密码等敏感信息。攻击者往往借助自动化脚本工具来发动暴力破解攻击。 攻击行为类型根据暴力破解的穷举方式，其攻击行为可以分为： 字典攻击法。大多攻击者并没有高性能的破解算法和CPU/GPU，为节省时间和提高效率，会利用社会工程学或其它方式建立破译字典，使用字典中已存在的用户名、密码进行猜破。 穷举法。攻击者首先列出密码组合的可能性（如数字、大写字母、小写字母、特殊字符等），然后按密码长度从1位、2位….构成不同的账号和密码对，然后逐个猜试。该方法需要高性能的破解算法和CPU/GPU作支持。 组合式攻击法。使用字典攻击和穷举法的组合攻击方式。 理论上，只要拥有性能足够强的计算机和足够长的时间，大多密码均可以被破解出来。 攻击业务类型 针对Windows操作系统的远程桌面管理协议（RDP）、Linux操作系统的管理协议（SSH）的暴力破解攻击 针对具有登录认证机制的软件服务（如Mysql、SQLserver、FTP、Web前后端登录接口等应用服务）的暴力破解攻击 对于防御者而言，给攻击者留得时间越长，其组合出正确的用户名和密码的可能性就越大。因此，时间在检测暴力破解攻击时很重要。 暴力破解攻击有什么危害通过自动化工具发起的暴力破解攻击可以获取用户账号和密码。 如何防御暴力破解攻击 制定密码复杂度策略，并进行服务加固。密码的长度要大于 8 位，且最好大于 20 位；密码应由数字、大小写字母和特殊符号混合组成；密码的最长有效期为 90 天。 配置好网络访问控制。严格限制将高危服务管理端口直接发布到互联网；建议您使用 VPN 和堡垒机的方式集中管理和审计。 提高内部全员安全意识，禁止借用或共享使用账号。]]></content>
      <categories>
        <category>Linux</category>
        <category>安全</category>
      </categories>
      <tags>
        <tag>安全</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Elasticsearch服务安全加固]]></title>
    <url>%2F2019%2F04%2F16%2FElasticsearch%E6%9C%8D%E5%8A%A1%E5%AE%89%E5%85%A8%E5%8A%A0%E5%9B%BA%2F</url>
    <content type="text"><![CDATA[引用自阿里云https://help.aliyun.com/knowledge_detail/49913.html&gt; Elasticsearch 是一个基于 Lucene 的搜索服务，它提供了 RESTful web 接口的分布式、多用户全文搜索引擎 。Elasticsearch 是用 Java 开发的，并作为 Apache 许可条款下的开放源码发布，是第二大最流行的企业搜索引擎。 Elasticsearch 应用于云计算中，具有实时搜索、稳定、可靠、快速、安装使用方便等优势；但也存在一些安全隐患：默认安装完成后，Elasticsearch 可以使用 9200 端口通告 web 的方式访问查看数据信息。 漏洞详情Elasticsearch 中存在以下高危漏洞。 类型 CVE 受影响版本 描述 远程命令执行 CVE-2014-3120 - Elasticsearch 的脚本执行 (scripting) 功能，可以很方便地对查询出来的数据进行再加工处理。但是，其使用的 MVEL 脚本引擎没有做过任何防护（或者沙盒包装），可以直接执行任意代码。 远程代码执行 - 1.3.0-1.3.7，1.4.0-1.4 Elasticsearch 使用 Groovy 作为脚本语言，虽然加入了沙盒进行控制，危险的代码会被拦截。但是由于沙盒限制不严格，仅通过黑白名单来判断，导致攻击者可以绕过沙盒，执行远程代码。 未授权访问 - - Elasticsearch 在安装了 River 机制之后可以同步多种数据库数据（包括关系型的MySQL、MongoDB 等）。如果 http://localhost:9200/cat/indices中 indices 包含了 _river，则代表 Elasticsearch 已安装 River 机制。而通过泄露的 http://localhost:9200/_rvier/_search URL 地址，攻击者可以获取到敏感信息。 漏洞成因与危害由于 Elasticsearch 的 HTTP 连接没有提供任何的权限控制措施，一旦部署在公共网络就容易有数据泄露的风险。 安全加固方案使用最新的 Elasticsearch 版本通过正规渠道（如 Elastic 官网）下载 Elasticsearch 的最新版本。 下载完成后，将下载文件的 sha1 值和下载时官网页面提供的 sha1 值进行对比，避免下载过程中被恶意攻击者拦截破坏文件，甚至注入恶意代码。 不要随便安装第三方的插件，插件有可能引入安全漏洞甚至本身自带后门，需谨慎使用。 关注 Elastic 网站，及时更新 Elasticsearch 至最新版本。Elasticsearch 每次版本发布都会优化和改进一部分功能，尤其是安全漏洞的补丁。同时，仔细阅读 Elasticsearch 的版本更新记录。 注意：更新升级前，建议您先进行快照备份，及本地测试。 （推荐）网络访问控制Elasticsearch 默认端口是 9200。 不要把 Elasticsearch 的 9200 端口服务发布到互联网上。 使用 阿里云安全组防火墙 或本地操作系统防火墙对访问源 IP 进行隔离控制。 绑定访问源 IP进入 config 目录，修改 elasticsearch.yml 配置文件中以下参数： 123456network.bind_host: 192.168.0.1# 设置绑定的 IP 地址，可以是 IPv4 或 IPv6 地址，默认为 0.0.0.0。network.publish_host: 192.168.0.1# 设置其它节点和该节点交互的 IP 地址，如果不设置它会自动判断，值必须是个真实的 IP 地址。network.host: 192.168.0.1# 同时设置上述两个参数：bind_host 和 publish_host。 修改默认端口进入 config 目录，修改 elasticsearch.yml 配置文件中以下参数： 123456ransport.tcp.port: 9300# 设置节点间交互的 TCP 端口，默认是 9300。transport.tcp.compress: true# 设置是否压缩 TCP 传输时的数据，默认为 false，即不压缩。http.port: 9200# 设置对外服务的 HTTP 端口，默认为 9200。 关闭 HTTP 访问进入 config 目录，修改 elasticsearch.yml 配置文件中以下参数： 12http.enabled: false# 是否使用 HTTP 协议对外提供服务，默认为 true，即开启。 使用 Shield 安全插件Shield 是 Elastic 公司为 Elasticsearch 开发的一个安全插件。在安装此插件后，Shield 会拦截所有对 Elasticsearch 的请求，并进行认证与加密，保障 Elasticsearch 及相关系统的安全性。Shield 是商业插件，需要 Elasticsearch 的商业许可。第一次安装许可的时候，会提供 30 天的免费试用权限。30 天后，Shield 将会屏蔽 clusterhealth, cluster stats, index stats 等 API，其余功能不受影响。 用户认证使用 Shield 可以定义一系列已知的用户，并用其认证用户请求。这些用户存在于抽象的“域”中。一个“域”可以是下面几种类型： LDAP 服务 ActiveDirectory 服务 本地 esusers 配置文件（类似 /etc/passwd) 权限控制Shield 的权限控制包含下面几种元素： 被保护的资源 SecuredResource：权限所应用到的对象，比如某个 index，cluster 等。 特权 Priviliege：角色对对象可以执行的一种或多种操作，比如 read，write 等。还可以是 indicies:/data/read/perlocate 等对某种对象特有的操作。 许可 Permissions：对被保护的资源拥有的一个或多个特权，如 read on the&quot;products&quot; index。 角色 Role：一组许可的集成，具有独立的名称。 用户 Users：用户实体，可以被赋予多种角色，他们可以对被保护的资源执行相应角色所拥有的各种特权。 安装 Shield执行安装步骤前，请确保满足以下安装环境条件： 您安装了 Java7 或更新版本。 您将 Elasticsearch 1.5.0+ 解压安装到了本机上。如果您使用 APT 或 YUM 安装，默认的安装目录可能在 /usr/share/elasticsearch。 参照以下步骤完成安装： 进入 Elasticsearch 安装目录： 1cd /usr/share/elasticsearch 安装 Elasticsearch 许可插件： 1bin/plugin -i elasticsearch/license/latest 安装 Shield 插件： 1bin/plugin -i elasticsearch/shield/latest 将 Shield 配置文件移动或链接至 /etc/elasticsearch/shield 目录中： 1ln -s /usr/share/elasticsearch/config/shield /etc/elasticsearch/shield 说明：Elasticsearch 服务在启动时会在 /etc/elasticsearch/shield 目录下寻找 Shield 配置文件，而这些配置文件在安装 Shield 时会出现在 /usr/share/elasticsearch/config/shield 中，因此需要将配置文件移动或链接至该目录。 重启 Elasticsearch 服务： 1service elasticsearch restart 新建一个 Elasticsearch 管理员账户，填写新密码： 1bin/shield/esusersuseradd es_admin -r admin 直接使用 RESTFUL API 访问 Elasticsearch 的请求都会被拒绝： 1curl -XGET&apos;http://localhost:9200/&apos; 需要在请求中添加用户名和密码： 1curl -u es_admin -XGET &apos;http://localhost:9200/&apos; 更多信息，请参考： Shield 官方安装指南 Shield 官方使用配置指南 修改默认的 Elasticsearch 集群名称Elasticsearch 默认的集群名称是 elasticsearch，请在您的生产环境中将其修改成其他名称。确保在不同的环境和不同的集群下使用不同的名称；并且在监控集群节点时，如果有未知节点加入，一定要及时预警。 不要以 root 身份运行 Elasticsearch不要以 root 身份来运行 Elasticsearch，不要和其他服务共用相同的用户，并把用户的权限最小化。 应用示例： 1sudo -u es-user ES_JAVA_OPTS=&quot;-Xms1024m -Xmx1024m&quot;/opt/elasticsearch/bin/elasticsearc 正确设置 Elasticsearch 的数据目录请确保为 Elasticsearch 的目录分配了合理的读写权限，避免使用共享文件系统。确保只有 Elasticsearch 的启动用户才有权访问目录。日志目录也需要正确配置，避免泄露敏感信息。 定期对 Elasticsearch 进行备份使用 Elasticsearch 提供的备份还原机制，定期对 Elasticsearch 的数据进行快照备份。 禁用批量删除索引Elasticsearch 支持使用全部（_all）和通配符（*）来批量删除索引。在生产环境，该操作存在一定风险，你可以通过设置 action.destructive_requires_name: true 参数来禁用它。 启用日志记录功能Elasticsearch 的 config 文件夹里面有两个配置文件： elasticsearch.yml：基本配置文件。 logging.yml：日志配置文件。由于 Elasticsearch 使用 log4j 来记录日志的，logging.yml 中的设置请按普通 log4j 配置文件进行设置。 启用日志功能需要修改 elasticsearch.yml 配置文件： 1path.logs: /path/to/logs# 设置日志文件的存储路径，默认是 Elasticsearch 根目录下的 logs 文件夹]]></content>
      <categories>
        <category>Elasticsearch</category>
      </categories>
      <tags>
        <tag>Elasticsearch</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Linux操作系统加固]]></title>
    <url>%2F2019%2F04%2F16%2FLinux%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%8A%A0%E5%9B%BA%2F</url>
    <content type="text"><![CDATA[引自阿里云https://help.aliyun.com/knowledge_detail/49809.html&gt; 本帮助手册旨在指导系统管理人员或安全检查人员进行Linux操作系统的安全合规性检查和加固。 1. 账号和口令1.1 禁用或删除无用账号减少系统无用账号，降低安全风险。 操作步骤 使用命令 userdel &lt;用户名&gt; 删除不必要的账号。 使用命令 passwd -l &lt;用户名&gt; 锁定不必要的账号。 使用命令 passwd -u &lt;用户名&gt; 解锁必要的账号。 1.2 检查特殊账号检查是否存在空口令和root权限的账号。 操作步骤 查看空口令和root权限账号，确认是否存在异常账号： 使用命令 awk -F: &#39;($2==&quot;&quot;)&#39; /etc/shadow 查看空口令账号。 使用命令 awk -F: &#39;($3==0)&#39; /etc/passwd 查看UID为零的账号。 加固空口令账号： 使用命令 passwd &lt;用户名&gt; 为空口令账号设定密码。 确认UID为零的账号只有root账号。 1.3 添加口令策略加强口令的复杂度等，降低被猜解的可能性。 操作步骤 使用命令 1vi /etc/login.defs 修改配置文件。 PASS_MAX_DAYS 90 #新建用户的密码最长使用天数 PASS_MIN_DAYS 0 #新建用户的密码最短使用天数 PASS_WARN_AGE 7 #新建用户的密码到期提前提醒天数 使用chage命令修改用户设置。例如，chage -m 0 -M 30 -E 2000-01-01 -W 7 &lt;用户名&gt;表示将此用户的密码最长使用天数设为30，最短使用天数设为0，密码2000年1月1日过期，过期前七天警告用户。 设置连续输错三次密码，账号锁定五分钟。使用命令 vi /etc/pam.d/common-auth修改配置文件，在配置文件中添加 auth required pam_tally.so onerr=fail deny=3 unlock_time=300。 1.4 限制用户su限制能su到root的用户。 操作步骤 使用命令 vi /etc/pam.d/su修改配置文件，在配置文件中添加行。例如，只允许test组用户su到root，则添加 auth required pam_wheel.so group=test。 1.4 禁止root用户直接登录限制root用户直接登录。 操作步骤 创建普通权限账号并配置密码,防止无法远程登录; 使用命令 vi /etc/ssh/sshd_config修改配置文件将PermitRootLogin的值改成no，并保存，然后使用service sshd restart重启服务。 2. 服务2.1 关闭不必要的服务关闭不必要的服务（如普通服务和xinetd服务），降低风险。 操作步骤 使用命令systemctl disable &lt;服务名&gt;设置服务在开机时不自动启动。 说明： 对于部分老版本的Linux操作系统（如CentOS 6），可以使用命令chkconfig --level &lt;init级别&gt; &lt;服务名&gt; off设置服务在指定init级别下开机时不自动启动。 2.2 SSH服务安全对SSH服务进行安全加固，防止暴力破解成功。 操作步骤 使用命令 vim /etc/ssh/sshd_config 编辑配置文件。 不允许root账号直接登录系统。设置 PermitRootLogin 的值为 no。 修改SSH使用的协议版本。设置 Protocol 的版本为 2。 修改允许密码错误次数（默认6次）。设置 MaxAuthTries 的值为 3。 配置文件修改完成后，重启sshd服务生效。 3. 文件系统3.1 设置umask值设置默认的umask值，增强安全性。 操作步骤 使用命令 vi /etc/profile 修改配置文件，添加行 umask 027， 即新创建的文件属主拥有读写执行权限，同组用户拥有读和执行权限，其他用户无权限。 3.2 设置登录超时设置系统登录后，连接超时时间，增强安全性。 操作步骤 使用命令 vi /etc/profile 修改配置文件，将以 TMOUT= 开头的行注释，设置为TMOUT=180，即超时时间为三分钟。 4. 日志4.1 syslogd日志启用日志功能，并配置日志记录。 操作步骤 Linux系统默认启用以下类型日志： 系统日志（默认）/var/log/messages cron日志（默认）/var/log/cron 安全日志（默认）/var/log/secure 注意：部分系统可能使用syslog-ng日志，配置文件为：/etc/syslog-ng/syslog-ng.conf。 您可以根据需求配置详细日志。 4.2 记录所有用户的登录和操作日志通过脚本代码实现记录所有用户的登录操作日志，防止出现安全事件后无据可查。 操作步骤 运行 [root@xxx /]# vim /etc/profile打开配置文件。 在配置文件中输入以下内容： 123456789101112131415161718historyUSER=`whoami`USER_IP=`who -u am i 2&gt;/dev/null| awk '&#123;print $NF&#125;'|sed -e 's/[()]//g'`if [ "$USER_IP" = "" ]; thenUSER_IP=`hostname`fiif [ ! -d /var/log/history ]; thenmkdir /var/log/historychmod 777 /var/log/historyfiif [ ! -d /var/log/history/$&#123;LOGNAME&#125; ]; thenmkdir /var/log/history/$&#123;LOGNAME&#125;chmod 300 /var/log/history/$&#123;LOGNAME&#125;fiexport HISTSIZE=4096DT=`date +"%Y%m%d_%H:%M:%S"`export HISTFILE="/var/log/history/$&#123;LOGNAME&#125;/$&#123;USER&#125;@$&#123;USER_IP&#125;_$DT"chmod 600 /var/log/history/$&#123;LOGNAME&#125;/*history* 2&gt;/dev/null 运行 [root@xxx /]# source /etc/profile 加载配置生效。注意： /var/log/history 是记录日志的存放位置，可以自定义。 通过上述步骤，可以在 /var/log/history 目录下以每个用户为名新建一个文件夹，每次用户退出后都会产生以用户名、登录IP、时间的日志文件，包含此用户本次的所有操作（root用户除外）。 同时，建议您使用OSS服务收集存储日志。]]></content>
      <categories>
        <category>Linux</category>
        <category>安全</category>
      </categories>
      <tags>
        <tag>Linux</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Ansible-快速添加免密码认证]]></title>
    <url>%2F2019%2F04%2F08%2FAnsible-%E5%BF%AB%E9%80%9F%E6%B7%BB%E5%8A%A0%E5%85%8D%E5%AF%86%E7%A0%81%E8%AE%A4%E8%AF%81%2F</url>
    <content type="text"><![CDATA[生成管理机的私钥和公钥1ssh-keygen -t rsa -b 2048 -P '' -f /root/.ssh/id_rsa 添加主机信息到主机清单中1vim /etc/ansible/hosts 123456789101112#添加分组[test-k8s]172.20.21.249172.20.21.250172.20.21.251172.20.21.252172.20.21.253172.20.21.254172.20.21.255172.20.22.0172.20.22.1172.20.22.2 配置playbook1vim /etc/ansible/ssh-addkey.yml 12345678910---- hosts: pro-k8s gather_facts: no tasks: - name: install ssh key authorized_key: user=root key="&#123;&#123; lookup('file', '/root/.ssh/id_rsa.pub') &#125;&#125;" state=present 运行playbook1ansible-playbook -i /etc/ansible/hosts -k /etc/ansible/ssh-addkey.yml 输入服务器密码 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465SSH password:PLAY [pro-k8s] ***************************************************************************************************************************TASK [install ssh key] *******************************************************************************************************************changed: [172.21.5.197]changed: [172.21.5.196]changed: [172.21.5.199]changed: [172.21.5.192]changed: [172.21.5.195]changed: [172.21.5.193]changed: [172.21.2.240]changed: [172.21.5.198]changed: [172.21.2.238]changed: [172.21.5.194]changed: [172.21.2.236]changed: [172.21.2.235]changed: [172.21.2.237]changed: [172.21.2.239]changed: [172.21.2.234]changed: [172.21.0.159]changed: [172.21.0.155]changed: [172.21.2.241]changed: [172.21.0.154]changed: [172.21.0.153]changed: [172.21.0.158]changed: [172.21.0.152]changed: [172.21.0.160]changed: [172.21.0.156]changed: [172.21.0.157]changed: [172.21.2.232]changed: [172.21.2.233]changed: [172.21.0.151]changed: [172.21.5.191]PLAY RECAP *******************************************************************************************************************************172.21.0.151 : ok=1 changed=1 unreachable=0 failed=0172.21.0.152 : ok=1 changed=1 unreachable=0 failed=0172.21.0.153 : ok=1 changed=1 unreachable=0 failed=0172.21.0.154 : ok=1 changed=1 unreachable=0 failed=0172.21.0.155 : ok=1 changed=1 unreachable=0 failed=0172.21.0.156 : ok=1 changed=1 unreachable=0 failed=0172.21.0.157 : ok=1 changed=1 unreachable=0 failed=0172.21.0.158 : ok=1 changed=1 unreachable=0 failed=0172.21.0.159 : ok=1 changed=1 unreachable=0 failed=0172.21.0.160 : ok=1 changed=1 unreachable=0 failed=0172.21.2.232 : ok=1 changed=1 unreachable=0 failed=0172.21.2.233 : ok=1 changed=1 unreachable=0 failed=0172.21.2.234 : ok=1 changed=1 unreachable=0 failed=0172.21.2.235 : ok=1 changed=1 unreachable=0 failed=0172.21.2.236 : ok=1 changed=1 unreachable=0 failed=0172.21.2.237 : ok=1 changed=1 unreachable=0 failed=0172.21.2.238 : ok=1 changed=1 unreachable=0 failed=0172.21.2.239 : ok=1 changed=1 unreachable=0 failed=0172.21.2.240 : ok=1 changed=1 unreachable=0 failed=0172.21.2.241 : ok=1 changed=1 unreachable=0 failed=0172.21.5.191 : ok=1 changed=1 unreachable=0 failed=0172.21.5.192 : ok=1 changed=1 unreachable=0 failed=0172.21.5.193 : ok=1 changed=1 unreachable=0 failed=0172.21.5.194 : ok=1 changed=1 unreachable=0 failed=0172.21.5.195 : ok=1 changed=1 unreachable=0 failed=0172.21.5.196 : ok=1 changed=1 unreachable=0 failed=0172.21.5.197 : ok=1 changed=1 unreachable=0 failed=0172.21.5.198 : ok=1 changed=1 unreachable=0 failed=0172.21.5.199 : ok=1 changed=1 unreachable=0 failed=0]]></content>
      <categories>
        <category>Ansible</category>
      </categories>
      <tags>
        <tag>Ansible</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Cookie & Session]]></title>
    <url>%2F2019%2F04%2F07%2FCookie-Session%2F</url>
    <content type="text"><![CDATA[https://www.cnblogs.com/liwenzhou/p/8343243.html CookieCookie是什么保存在浏览器端的键值对 为什么要有Cookie因为HTTP请求是无状态的 Cookie的原理服务端可以在返回响应的时候 做手脚在浏览器上写入键值对，就是Cookie，浏览器发送请求的时候会自动携带该网站保存在浏览器中的键值对 Cookie的使用场景 保存登录信息 保存用户的搜索关键词 Django中操作Cookie获取Cookie1234567request.COOKIES['key']request.get_signed_cookie(key, default=RAISE_ERROR, salt='', max_age=None)参数： default: 默认值 salt: 加密盐 max_age: 后台控制过期时间 设置Cookie123456789101112131415rep = HttpResponse(...)rep ＝ render(request, ...)rep.set_cookie(key,value,...)rep.set_signed_cookie(key,value,salt='加密盐', max_age=None, ...)参数： key, 键 value='', 值 max_age=None, 超时时间 expires=None, 超时时间(IE requires expires, so set it if hasn't been already.) path='/', Cookie生效的路径，/ 表示根路径，特殊的：根路径的cookie可以被任何url的页面访问 domain=None, Cookie生效的域名 secure=False, https传输 httponly=False 只能http协议传输，无法被JavaScript获取（不是绝对，底层抓包可以获取到也可以被覆盖） 删除Cookie1234def logout(request): rep = redirect("/login/") rep.delete_cookie("user") # 删除用户浏览器上之前设置的usercookie值 return rep 完整views.py示例：12345678910111213141516171819202122232425262728293031323334353637383940414243444546# -*- coding: utf-8 -*-from __future__ import unicode_literalsfrom django.shortcuts import render,redirectfrom django.http import HttpResponse,HttpResponseRedirectfrom django.shortcuts import render# Create your views here.def check_login(func): def a(request,*args,**kwargs): Cookies = request.COOKIES.get("is_login", None) if 'yes' != Cookies: return redirect('/test01/login') else: return func(request,*args,**kwargs) return a@check_logindef index(request): return HttpResponse('index界面')@check_logindef home(request): return HttpResponse('home')def login(request): return render(request,'test01/login.html')@check_logindef logout(request): rep = redirect('/test01/login') rep.delete_cookie('is_login') return repdef check_username(request): if request.method == "POST": username = request.POST.get('username',None) password = request.POST.get('password',None) if username == 'z' and password == 'z': rep = render(request,'test01/home.html',&#123;'username':username&#125;) #rep.set_cookie('is_login','yes') rep.set_signed_cookie('is_login', 'yes', expires=60 * 60 * 24 * 7) else: rep = redirect('/test01/login') else: rep = redirect('/test01/login') return rep SessionCookie虽然在一定程度上解决了“保持状态”的需求，但是由于Cookie本身最大支持4096字节，以及Cookie本身保存在客户端，可能被拦截或窃取，因此就需要有一种新的东西，它能支持更多的字节，并且他保存在服务器，有较高的安全性。这就是Session。 问题来了，基于HTTP协议的无状态特征，服务器根本就不知道访问者是“谁”。那么上述的Cookie就起到桥接的作用。 我们可以给每个客户端的Cookie分配一个唯一的id，这样用户在访问时，通过Cookie，服务器就知道来的人是“谁”。然后我们再根据不同的Cookie的id，在服务器上保存一段时间的私密资料，如“账号密码”等等。 总结而言：Cookie弥补了HTTP无状态的不足，让服务器知道来的人是“谁”；但是Cookie以文本的形式保存在本地，自身安全性较差；所以我们就通过Cookie识别不同的用户，对应的在Session里保存私密的信息以及超过4096字节的文本。另外，上述所说的Cookie和Session其实是共通性的东西，不限于语言和框架。 Django中操作Session1234567891011121314151617181920212223242526272829303132333435363738# 获取、设置、删除Session中数据request.session['k1']request.session.get('k1',None)request.session['k1'] = 123request.session.setdefault('k1',123) # 存在则不设置del request.session['k1']# 所有 键、值、键值对request.session.keys()request.session.values()request.session.items()request.session.iterkeys()request.session.itervalues()request.session.iteritems()# 会话session的keyrequest.session.session_key# 将所有Session失效日期小于当前日期的数据删除request.session.clear_expired()# 检查会话session的key在数据库中是否存在request.session.exists("session_key")# 删除当前会话的所有Session数据request.session.delete() # 删除当前的会话数据并删除会话的Cookie。request.session.flush() 这用于确保前面的会话数据不可以再次被用户的浏览器访问 例如，django.contrib.auth.logout() 函数中就会调用它。# 设置会话Session和Cookie的超时时间request.session.set_expiry(value) * 如果value是个整数，session会在些秒数后失效。 * 如果value是个datatime或timedelta，session就会在这个时间后失效。 * 如果value是0,用户关闭浏览器session就会失效。 * 如果value是None,session会依赖全局session失效策略。 Seesion版验证登录12345678910111213141516171819202122232425262728293031323334353637383940from functools import wrapsdef check_login(func): @wraps(func) def inner(request, *args, **kwargs): next_url = request.get_full_path() if request.session.get("user"): return func(request, *args, **kwargs) else: return redirect("/login/?next=&#123;&#125;".format(next_url)) return innerdef login(request): if request.method == "POST": user = request.POST.get("user") pwd = request.POST.get("pwd") if user == "alex" and pwd == "alex1234": # 设置session request.session["user"] = user # 获取跳到登陆页面之前的URL next_url = request.GET.get("next") # 如果有，就跳转回登陆之前的URL if next_url: return redirect(next_url) # 否则默认跳转到index页面 else: return redirect("/index/") return render(request, "login.html")@check_logindef logout(request): # 删除所有当前请求相关的session request.session.delete() return redirect("/login/")@check_logindef index(request): current_user = request.session.get("user", None) return render(request, "index.html", &#123;"user": current_user&#125;) Django中的Session配置12345678910111213141516171819202122232425261. 数据库SessionSESSION_ENGINE = 'django.contrib.sessions.backends.db' # 引擎（默认）2. 缓存SessionSESSION_ENGINE = 'django.contrib.sessions.backends.cache' # 引擎SESSION_CACHE_ALIAS = 'default' # 使用的缓存别名（默认内存缓存，也可以是memcache），此处别名依赖缓存的设置3. 文件SessionSESSION_ENGINE = 'django.contrib.sessions.backends.file' # 引擎SESSION_FILE_PATH = None # 缓存文件路径，如果为None，则使用tempfile模块获取一个临时地址tempfile.gettempdir() 4. 缓存+数据库SESSION_ENGINE = 'django.contrib.sessions.backends.cached_db' # 引擎5. 加密Cookie SessionSESSION_ENGINE = 'django.contrib.sessions.backends.signed_cookies' # 引擎其他公用设置项：SESSION_COOKIE_NAME ＝ "sessionid" # Session的cookie保存在浏览器上时的key，即：sessionid＝随机字符串（默认）SESSION_COOKIE_PATH ＝ "/" # Session的cookie保存的路径（默认）SESSION_COOKIE_DOMAIN = None # Session的cookie保存的域名（默认）SESSION_COOKIE_SECURE = False # 是否Https传输cookie（默认）SESSION_COOKIE_HTTPONLY = True # 是否Session的cookie只支持http传输（默认）SESSION_COOKIE_AGE = 1209600 # Session的cookie失效日期（2周）（默认）SESSION_EXPIRE_AT_BROWSER_CLOSE = False # 是否关闭浏览器使得Session过期（默认）SESSION_SAVE_EVERY_REQUEST = False # 是否每次请求都保存Session，默认修改之后才保存（默认）]]></content>
      <tags>
        <tag>Cookie</tag>
        <tag>Session</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Nginx_配置SSL证书]]></title>
    <url>%2F2019%2F04%2F05%2FNginx-%E9%85%8D%E7%BD%AESSL%E8%AF%81%E4%B9%A6%2F</url>
    <content type="text"><![CDATA[获取证书并上传到Ngx服务器 检查Ngx是否安装–with-http_ssl_module模块 修改nginx配置文件 123456789101112131415161718192021222324252627282930313233server &#123; listen 80; server_name *.zhaohongye.com; #return 301 https://$host$request_uri; return 301 https://zhaohongye.com;&#125;server &#123; listen 443 ssl; server_name zhaohongye.com www.zhaohongye.com; access_log /var/log/nginx/zhy.log main; error_log /var/log/nginx/zhy.error.log; ssl on; #ssl功能开启 ssl_certificate sslfile/2027481_zhaohongye.com.pem; ssl_certificate_key sslfile/2027481_zhaohongye.com.key; location / &#123; proxy_set_header Host $host:$server_port; proxy_set_header X-Real-IP $remote_addr; proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for; proxy_set_header X-Forwarded-Proto $scheme; proxy_redirect http:// https://; proxy_pass http://127.0.0.1:4000; client_max_body_size 10M; proxy_set_header X-Forwarded-Host $host; proxy_set_header X-Forwarded-Server $host; # Required for new HTTP-based CLI proxy_http_version 1.1; proxy_request_buffering off; &#125;&#125; https访问验证]]></content>
      <categories>
        <category>Nginx</category>
      </categories>
      <tags>
        <tag>Nginx</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Archer]]></title>
    <url>%2F2019%2F04%2F05%2FArcher-SQL%E8%87%AA%E5%8A%A8%E5%8C%96%E5%B9%B3%E5%8F%B0%2F</url>
    <content type="text"><![CDATA[ARCHER — 自动化SQL操作平台基于inception的自动化SQL操作平台，支持SQL执行、LDAP认证、发邮件、OSC、SQL查询、SQL优化建议、权限管理等功能，支持docker镜像。 GitHub项目地址：https://github.com/jly8866/archer 主要功能 自动审核发起SQL上线，工单提交，由inception自动审核，审核通过后需要由审核人进行人工审核 人工审核inception自动审核通过的工单，由其他研发工程师或研发经理来审核，DBA操作执行SQL为什么要有人工审核？这是遵循运维领域线上操作的流程意识，一个工程师要进行线上数据库SQL更新，最好由另外一个工程师来把关很多时候DBA并不知道SQL的业务含义，所以人工审核最好由其他研发工程师或研发经理来审核. 这是archer的设计理念 回滚数据展示工单内可展示回滚语句，支持一键提交回滚工单 定时执行SQL审核通过的工单可由DBA选择定时执行，执行前可修改执行时间，可随时终止 pt-osc执行支持pt-osc执行进度展示，并且可以点击中止pt-osc进程 MySQL查询库、表、关键字自动补全查询结果集限制、查询结果导出、表结构展示、多结果集展示 MySQL查询权限管理基于inception解析查询语句，查询权限支持限制到表级查询权限申请、审核和管理，支持审核流程配置，多级审核 MySQL查询动态脱敏基于inception解析查询语句，配合脱敏字段配置、脱敏规则(正则表达式)实现敏感数据动态脱敏 慢日志管理基于percona-toolkit的pt_query_digest分析和存储慢日志，并在web端展现 邮件通知可配置邮件提醒，对上线申请、权限申请、审核结果等进行通知对异常登录进行通知 安装安装docker 、git1yum install -y docker git 下载镜像123docker pull hhyo/inceptiondocker pull hhyo/archerdocker pull mysql:5.6.35 创建archer配置文件服务目录定为 /vcg/archer/ 1mkdir /vcg/archer/ 123456789101112131415161718192021222324vim /vcg/archer/inc.cnf[inception]general_log=1general_log_file=inception.logport=6669socket=/tmp/inc.socketcharacter-set-client-handshake=0character-set-server=utf8inception_remote_system_password=rootinception_remote_system_user=wzf1inception_remote_backup_port=3306inception_remote_backup_host=127.0.0.1inception_support_charset=utf8,utf8mb4inception_enable_nullable=0inception_check_primary_key=1inception_check_column_comment=1inception_check_table_comment=1inception_osc_on=OFFinception_osc_bin_dir=/usr/bininception_osc_min_table_size=1inception_osc_chunk_time=0.1inception_enable_blob_type=1inception_check_column_default_value=1 12wget https://github.com/jly8866/archer/blob/master/archer/settings.py修改其中的数据库地址、用户名、密码 启动容器12345docker run --name inception -v /vcg/archer/inc.cnf:/etc/inc.cnf -p 6669:6669 -dti hhyo/inceptiondocker run --name mysql -p 3306:3306 -e MYSQL_ROOT_PASSWORD=123456 -d mysql:5.6.35docker run --name archer -v /vcg/archer/settings.py:/opt/archer/archer/settings.py -e NGINX_PORT=9123 -p 9123:9123 -dti hhyo/archer 创建数据库123mysql -uroot -pCREATE DATABASE IF NOT EXISTS archer_github DEFAULT CHARSET utf8 COLLATE utf8_general_ci; 初始化数据库12345678docker exec -ti archer /bin/bash cd /opt/archer source /opt/venv4archer/bin/activate # 初始化数据库 python3 manage.py makemigrations sql python3 manage.py migrate # 创建管理员账号 python3 manage.py createsuperuser 访问地址： http://xxxx::9123/]]></content>
      <categories>
        <category>Archer</category>
      </categories>
      <tags>
        <tag>Archer</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Hexo]]></title>
    <url>%2F2019%2F04%2F05%2FHexo-%E5%8D%9A%E5%AE%A2%2F</url>
    <content type="text"><![CDATA[快速、简洁且高效的博客框架官网: https://hexo.io 特点超快速度Node.js 所带来的超快生成速度，让上百个页面在几秒内瞬间完成渲染。 支持 MarkdownHexo 支持 GitHub Flavored Markdown 的所有功能，甚至可以整合 Octopress 的大多数插件。 一键部署只需一条指令即可部署到 GitHub Pages, Heroku 或其他网站。 丰富的插件Hexo 拥有强大的插件系统，安装插件可以让 Hexo 支持 Jade, CoffeeScript。 12345$ npm install hexo-cli -g$ hexo init blog$ cd blog$ npm install$ hexo server 最佳实践命令缩写hexo支持指令缩写，例如：hexo generate和hexo g是等效的。d = deploy 部署g = generate 生成静态页面l = log 启动日记记录，使用覆盖记录格式n = new 新建文章o = output 设置输出路径p = port 重设端口s = server 启动服务器w = watch 监视文件变动 组合命令1hexo clean &amp;&amp; hexo g &amp;&amp; hexo d 修改首页博客为预览模式12345vim themes/next/_config.ymlauto_excerpt: enable: false length: 150 将 auto_excerpt的enable参数由false改为true]]></content>
      <categories>
        <category>Hexo</category>
      </categories>
      <tags>
        <tag>Hexo</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Kubernetes_Nginx-Ingress]]></title>
    <url>%2F2019%2F04%2F05%2FKubernetes-Nginx-Ingress%2F</url>
    <content type="text"><![CDATA[For example12345678910111213141516171819202122232425262728293031apiVersion: extensions/v1beta1kind: Ingressmetadata: annotations: nginx.ingress.kubernetes.io/force-ssl-redirect: 'true' #代表其中跳转 nginx.ingress.kubernetes.io/service-weight: '' nginx.ingress.kubernetes.io/ssl-redirect: 'true' creationTimestamp: '2018-12-25T10:29:36Z' generation: 1 name: boss namespace: default resourceVersion: '21429383' selfLink: /apis/extensions/v1beta1/namespaces/default/ingresses/boss uid: fa56e2a0-082f-11e9-80cf-00163e0e2421spec: rules: - host: boss1.vcg.com http: paths: - backend: serviceName: node-vcg-boss servicePort: 80 path: / tls: - hosts: - boss1.vcg.com secretName: vcg-httpsstatus: loadBalancer: ingress: - ip: 39.97.21.16]]></content>
      <categories>
        <category>Kubernetes</category>
      </categories>
      <tags>
        <tag>Kubernetes</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Hello World]]></title>
    <url>%2F2019%2F04%2F03%2Fhello-world%2F</url>
    <content type="text"><![CDATA[Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new "My New Post" More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment]]></content>
  </entry>
</search>
